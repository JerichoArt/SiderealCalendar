<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Sidereal Calendar</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <link rel="manifest" href="manifest.json"> <script src="https://cdn.tailwindcss.com"></script>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;700&display=swap" rel="stylesheet">
  <style>
    html, body {
      background-color: #f7fafc;
      color: #1a202c;
      margin: 0;
      padding: 0;
      font-family: 'Inter', sans-serif;
    }
    table {
      width: 100%;
      table-layout: fixed;
      border-collapse: collapse;
      border: 1px solid #e2e8f0;
      background-color: white;
    }
    th, td {
      border: 1px solid #e2e8f0;
      padding: 0.75rem;
      text-align: left;
      vertical-align: top;
    }
    /* Sticky controls section */
    .controls {
        position: sticky; /* Make controls sticky */
        top: 0; /* Stick to the top of the viewport */
        z-index: 10; /* Ensure it's above other content when sticky */
        background-color: white; /* Ensure it covers content when sticky */
        padding: 1rem;
        border-radius: 0.5rem;
        box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -1px rgba(0, 0, 0, 0.06);
    }
    /* Table header (thead th) will now scroll normally with the table */
    thead th {
      background-color: #edf2f7; /* Background color for the header cells */
      text-align: center;
      font-weight: 500;
      color: #4a5568;
      /* Removed: position: sticky, top, z-index, as the whole thead will scroll */
    }
    .day-number {
      font-size: 1.5rem;
      font-weight: bold;
      text-align: center;
      width: 70px;
      background-color: #f7fafc;
    }
    .whole-day-cell {
        min-height: 50px;
    }
    .nare-cell {
      min-height: 90px;
      overflow-wrap: break-word;
      position: relative;
    }
    .nare-content, .whole-day-content {
      min-height: 50px;
      width: 100%;
      outline: none;
      padding: 4px;
    }
    .nare-content:focus, .whole-day-content:focus {
        box-shadow: 0 0 0 2px rgba(66, 153, 225, 0.5);
        border-radius: 4px;
    }
	.nare-working-hours {
        background-color: #d1f7d1; /* A light green for working hours (screen display) */
    }

    .selected {
      background-color: #fefcbf; /* Softer yellow */
      border-color: #fbd38d;
    }
    .today-highlight {
        background-color: #c6f6d5; /* Light green */
    }
    .today-highlight-nare {
        background-color: #9ae6b4; /* Darker green */
    }
    button {
        transition: background-color 0.2s ease-in-out, transform 0.1s ease-in-out;
    }
    button:active {
        transform: scale(0.98);
    }
    @media print {
      body {
        background: white;
        color: black;
      }
      /* Hide controls and specific buttons when printing */
      .controls, #merge-btn, #unmerge-btn, #print-btn, #today-btn, #year-select, #month-select, #season-select, label {
        display: none !important;
      }
      /* Ensure table borders are visible */
      table, th, td {
          border: 1px solid #ccc;
      }
      /* Print style for working hours: light grey fill */
      .nare-working-hours {
        background-color: #f0f0f0 !important; /* Very light grey for print */
        -webkit-print-color-adjust: exact; /* For WebKit browsers to print background colors */
        print-color-adjust: exact; /* Standard property for printing background colors */
      }
    }
  </style>
</head>
<body class="p-4 md:p-6">
  <div class="max-w-7xl mx-auto">
      <h1 class="text-3xl font-bold mb-4 text-center text-gray-800">Sidereal Calendar</h1>

      <div class="controls flex flex-wrap items-center gap-4 mb-4">
        <label class="flex items-center gap-2">Year: <select id="year-select" class="border border-gray-300 rounded px-2 py-1"></select></label>
        <label class="flex items-center gap-2">Season: <select id="season-select" class="border border-gray-300 rounded px-2 py-1"></select></label>
        <label class="flex items-center gap-2">Month: <select id="month-select" class="border border-gray-300 rounded px-2 py-1"></select></label>
        <div class="flex gap-2 ml-auto">
          <button id="merge-btn" class="bg-yellow-400 hover:bg-yellow-500 text-yellow-800 font-semibold px-4 py-2 rounded-md shadow-sm">Merge</button>
          <button id="unmerge-btn" class="bg-indigo-400 hover:bg-indigo-500 text-white font-semibold px-4 py-2 rounded-md shadow-sm">Unmerge</button>
          <button id="print-btn" class="bg-blue-500 hover:bg-blue-600 text-white font-semibold px-4 py-2 rounded-md shadow-sm">Print</button>
		  <button id="today-btn" class="bg-cyan-500 hover:bg-cyan-600 text-white font-semibold px-4 py-2 rounded-md shadow-sm">Today</button>
        </div>
      </div>

      <div class="overflow-x-auto shadow-lg rounded-lg">
        <table id="calendar-table">
          <thead>
            <tr id="header-row-main">
              <th rowspan="2">Day</th>
              <th rowspan="2">Whole Day</th>
              <th colspan="10">Nares</th>
            </tr>
             <tr id="header-row-sub">
                <th>1</th><th>2</th><th>3</th><th>4</th><th>5</th>
                <th>6</th><th>7</th><th>8</th><th>9</th><th>10</th>
            </tr>
          </thead>
          <tbody id="calendar-body"></tbody>
        </table>
      </div>
  </div>

  <script>
    document.addEventListener("DOMContentLoaded", function () {
      // --- DOM Elements ---
      const calendarBody = document.getElementById("calendar-body");
      const mergeBtn = document.getElementById("merge-btn");
      const unmergeBtn = document.getElementById("unmerge-btn");
      const printBtn = document.getElementById("print-btn");
      const todayBtn = document.getElementById("today-btn");
      const yearSelect = document.getElementById("year-select");
      const seasonSelect = document.getElementById("season-select");
      const monthSelect = document.getElementById("month-select");

      // --- Calendar & Clock Constants ---
      const DAYS_IN_MONTH = 50;
      const NARES_PER_DAY = 10;
      const SIDEREAL_YEAR_SECS = (365 * 86400) + (5 * 3600) + (48 * 60) + 45;
      // Epoch set to J2000 epoch as 0 hour for both calendars (UTC)
      const EPOCH = new Date('2000-01-01T00:00:00.000Z'); 
      const DAYS_IN_YEAR = 1000;
      const MONTHS_PER_SEASON = 5;
      const PINGS_PER_SEC = 10;
      const SECS_PER_DIN = 10;
      const DINS_PER_NARE = 50;
      const PING_LENGTH = SIDEREAL_YEAR_SECS / (DAYS_IN_YEAR * NARES_PER_DAY * DINS_PER_NARE * SECS_PER_DIN * PINGS_PER_SEC);
      const SECONDS_PER_NARE_REAL = SIDEREAL_YEAR_SECS / (DAYS_IN_YEAR * NARES_PER_DAY);

      let selectedCells = [];
      let currentHighlight = null;

      // --- Sidereal Clock Logic (from real-world to sidereal) ---
      function getSiderealDate() {
        const nowDate = new Date(); // Current real-world date/time
        const elapsed = (nowDate - EPOCH) / 1000; // Elapsed seconds from EPOCH
        const totalPings = elapsed / PING_LENGTH;
        
        const totalNares = totalPings / (PINGS_PER_SEC * SECS_PER_DIN * DINS_PER_NARE);
        const totalDays = Math.floor(totalNares / NARES_PER_DAY);
        
        const siderealYear = Math.floor(elapsed / SIDEREAL_YEAR_SECS);
        const dayOfYear = totalDays % DAYS_IN_YEAR;
        
        const daysPerSeason = DAYS_IN_MONTH * MONTHS_PER_SEASON;
        const seasonIndex = Math.floor(dayOfYear / daysPerSeason);
        const dayInSeason = dayOfYear % daysPerSeason;
        
        const monthIndex = Math.floor(dayInSeason / DAYS_IN_MONTH);
        const dayInMonth = (dayInSeason % DAYS_IN_MONTH) + 1; // 1-indexed day
        
        const nareOfDay = Math.floor(totalNares % NARES_PER_DAY) + 1; // 1-indexed Nare

        return { year: siderealYear, season: seasonIndex, month: monthIndex, day: dayInMonth, nare: nareOfDay };
      }

      // --- New function: Convert Sidereal to Gregorian (from sidereal to real-world) ---
      function getGregorianDateFromSidereal(siderealYear, seasonIndex, monthIndex, dayInMonth, nareNumber) {
          const daysPerSeason = DAYS_IN_MONTH * MONTHS_PER_SEASON;
          // Calculate total sidereal days from Epoch to the beginning of the target sidereal day
          const totalSiderealDaysFromEpoch = 
              (siderealYear * DAYS_IN_YEAR) + 
              (seasonIndex * daysPerSeason) + 
              (monthIndex * DAYS_IN_MONTH) + 
              (dayInMonth - 1); // dayInMonth is 1-indexed, convert to 0-indexed for calculation

          // Calculate total Nares from Epoch to the beginning of the target Nare
          const totalNaresFromEpoch = (totalSiderealDaysFromEpoch * NARES_PER_DAY) + (nareNumber - 1); // nareNumber is 1-indexed

          // Calculate total real-world seconds from Epoch to the beginning of the target Nare
          const elapsedRealSeconds = totalNaresFromEpoch * SECONDS_PER_NARE_REAL;

          // Add these elapsed seconds (converted to milliseconds) to the EPOCH date
          return new Date(EPOCH.getTime() + (elapsedRealSeconds * 1000));
      }

      // --- Data Persistence (Local Storage) ---
      function getStorageKey() {
        return `sidereal-calendar-${yearSelect.value}-${seasonSelect.value}-${monthSelect.value}`;
      }

      function saveData() {
        const key = getStorageKey();
        const data = {
          wholeDay: {},
          nares: {}
        };
        const rows = calendarBody.querySelectorAll('tr');
        rows.forEach((row, dayIndex) => {
          const day = dayIndex + 1;
          const wholeDayContent = row.querySelector('.whole-day-content');
          if (wholeDayContent && wholeDayContent.innerHTML) {
            data.wholeDay[day] = wholeDayContent.innerHTML;
          }

          const nareCells = row.querySelectorAll('.nare-cell');
          nareCells.forEach(cell => {
            // Only save if the cell is visible (not hidden due to merge) or if it's the start of a merged block
            if (cell.style.display !== 'none' || cell.colSpan > 1) { 
              const nare = cell.dataset.nare;
              const content = cell.querySelector('.nare-content').innerHTML;
              const colspan = cell.colSpan;
              if (content || colspan > 1) { // Save if content exists or if it's a merged cell
                if (!data.nares[day]) data.nares[day] = {};
                data.nares[day][nare] = { content, colspan };
              }
            }
          });
        });
        localStorage.setItem(key, JSON.stringify(data));
      }

      function loadData() {
        const key = getStorageKey();
        const data = JSON.parse(localStorage.getItem(key));
        
        // Reset all cells to default display/colspan before loading
        const allNareCells = calendarBody.querySelectorAll('.nare-cell');
        allNareCells.forEach(cell => {
            cell.style.display = '';
            cell.colSpan = 1;
            cell.querySelector('.nare-content').innerHTML = ''; // Clear content to ensure fresh load
        });

        if (!data) return;

        // Load whole day content
        for (const day in data.wholeDay) {
          const cell = calendarBody.querySelector(`tr:nth-child(${day}) .whole-day-content`);
          if (cell) cell.innerHTML = data.wholeDay[day];
        }

        // Load nare content and handle merges
        for (const day in data.nares) {
          for (const nare in data.nares[day]) {
            const cellData = data.nares[day][nare];
            const cell = calendarBody.querySelector(`.nare-cell[data-day='${day}'][data-nare='${nare}']`);
            if (!cell) continue;

            cell.querySelector('.nare-content').innerHTML = cellData.content || '';
            if (cellData.colspan > 1) {
              cell.colSpan = cellData.colspan;
              // Hide the cells that are spanned over
              for (let i = 1; i < cellData.colspan; i++) {
                const nextNare = parseInt(nare) + i;
                const nextCell = calendarBody.querySelector(`.nare-cell[data-day='${day}'][data-nare='${nextNare}']`);
                if (nextCell) nextCell.style.display = 'none';
              }
            }
          }
        }
      }

      // --- UI & Calendar Generation ---
      
      function createCalendar() {
        calendarBody.innerHTML = ''; // Clear existing calendar
        for (let day = 1; day <= DAYS_IN_MONTH; day++) {
          const tr = document.createElement("tr");
          tr.dataset.dayRow = day;

          const dayTd = document.createElement("td");
          dayTd.className = "day-number";
          dayTd.textContent = day;
          tr.appendChild(dayTd);

          const wholeDayTd = document.createElement("td");
          wholeDayTd.className = "whole-day-cell";
          const wholeContent = document.createElement("div");
          wholeContent.contentEditable = true;
          wholeContent.className = "whole-day-content";
          wholeContent.addEventListener('input', saveData);
          wholeDayTd.appendChild(wholeContent);
          tr.appendChild(wholeDayTd);

          for (let i = 1; i =< NARES_PER_DAY; i++) {
            const td = document.createElement("td");
            td.className = "nare-cell";
            td.dataset.day = day;
            td.dataset.nare = i;
            const nareContent = document.createElement("div");
            nareContent.className = "nare-content";
            nareContent.contentEditable = true;
            nareContent.addEventListener('input', saveData);
            td.appendChild(nareContent);
            td.addEventListener("click", (e) => handleCellClick(e, td));
            tr.appendChild(td);
          }
          
          calendarBody.appendChild(tr);
        }
        loadData(); // Load data after creating the structure
        highlightWorkingHours(); // Call the dynamic highlighting function after loading data
      }

      // --- Function to dynamically highlight working hours (9 AM - 5 PM) ---
      function highlightWorkingHours() {
          const rows = calendarBody.querySelectorAll('tr');
          const currentSiderealYear = parseInt(yearSelect.value);
          const currentSeasonIndex = parseInt(seasonSelect.value);
          const currentMonthIndex = parseInt(monthSelect.value);

          rows.forEach(row => {
              const siderealDayInMonth = parseInt(row.dataset.dayRow);
              const nareCells = row.querySelectorAll('.nare-cell');

              nareCells.forEach(cell => {
                  cell.classList.remove('nare-working-hours'); // Reset first

                  const nareNumber = parseInt(cell.dataset.nare); // 1-indexed Nare

                  // Calculate Gregorian start Date object for this Nare
                  const gregorianNareStart = getGregorianDateFromSidereal(
                      currentSiderealYear,
                      currentSeasonIndex,
                      currentMonthIndex,
                      siderealDayInMonth,
                      nareNumber
                  );
                  
                  // Calculate Gregorian end time of this Nare
                  const gregorianNareEnd = new Date(gregorianNareStart.getTime() + (SECONDS_PER_NARE_REAL * 1000));

                  // Get the local date components from the Nare's start time
                  const nareLocalYear = gregorianNareStart.getFullYear();
                  const nareLocalMonth = gregorianNareStart.getMonth();
                  const nareLocalDay = gregorianNareStart.getDate();

                  // Create Date objects for 9 AM and 5 PM in the *local timezone* for the Nare's day
                  // These will automatically convert to UTC timestamps based on local timezone offset
                  const workingHoursStart = new Date(nareLocalYear, nareLocalMonth, nareLocalDay, 9, 0, 0);
                  const workingHoursEnd = new Date(nareLocalYear, nareLocalMonth, nareLocalDay, 17, 0, 0);

                  // Check for overlap between Nare time window and working hours window
                  // A Nare is highlighted if any part of it falls within the 9 AM - 5 PM window
                  const isWorkingHours = (gregorianNareEnd.getTime() > workingHoursStart.getTime()) &&
                                         (gregorianNareStart.getTime() < workingHoursEnd.getTime());
                  
                  if (isWorkingHours) {
                      cell.classList.add('nare-working-hours');
                  }
              });
          });
      }

      // --- Event Handlers ---
      function handleCellClick(event, cell) {
        if (!event.ctrlKey && !event.shiftKey) { // Allow Ctrl/Shift for multiple selection
            selectedCells.forEach(c => c.classList.remove("selected"));
            selectedCells = [];
        }
        if (selectedCells.includes(cell)) {
            cell.classList.remove("selected");
            selectedCells = selectedCells.filter(c => c !== cell);
        } else {
            cell.classList.add("selected");
            selectedCells.push(cell);
        }
      }
      
      function handleDropdownChange() {
        createCalendar(); // This will also trigger loadData for the new selection and call highlightWorkingHours
      }

      mergeBtn.addEventListener("click", () => {
        if (selectedCells.length < 2) {
            alert("Select at least two Nares to merge.");
            return;
        }
        selectedCells.sort((a, b) => parseInt(a.dataset.nare) - parseInt(b.dataset.nare));
        
        const firstDay = selectedCells[0].dataset.day;
        if (!selectedCells.every(cell => cell.dataset.day === firstDay)) {
            alert("You can only merge Nares from the same day.");
            return;
        }

        // Check for continuity and if any selected cell is already part of a merge
        for (let i = 0; i < selectedCells.length - 1; i++) {
            const currentNare = parseInt(selectedCells[i].dataset.nare);
            const nextNare = parseInt(selectedCells[i+1].dataset.nare);
            if (nextNare !== currentNare + 1) {
                alert("Selected Nares must be consecutive to merge.");
                selectedCells.forEach(c => c.classList.remove("selected"));
                selectedCells = [];
                return;
            }
            if (selectedCells[i].colSpan > 1 || selectedCells[i].style.display === 'none') {
                 alert("Cannot merge cells that are already part of an existing merge.");
                 selectedCells.forEach(c => c.classList.remove("selected"));
                 selectedCells = [];
                 return;
            }
        }
        // Also check the last cell if it's already merged
        if (selectedCells[selectedCells.length - 1].colSpan > 1 || selectedCells[selectedCells.length - 1].style.display === 'none') {
             alert("Cannot merge cells that are already part of an existing merge.");
             selectedCells.forEach(c => c.classList.remove("selected"));
             selectedCells = [];
             return;
        }


        const firstCell = selectedCells[0];
        let mergedContent = selectedCells.map(cell => cell.querySelector('.nare-content').innerHTML).filter(Boolean);
        firstCell.querySelector('.nare-content').innerHTML = mergedContent.join("<br>");
        firstCell.colSpan = selectedCells.length;
        firstCell.style.display = ''; // Ensure first cell is visible

        for (let i = 1; i < selectedCells.length; i++) {
            selectedCells[i].style.display = 'none';
        }

        selectedCells.forEach(c => c.classList.remove("selected"));
        selectedCells = [];
        saveData(); // Save the new merged state
      });

      unmergeBtn.addEventListener("click", () => {
          if (selectedCells.length !== 1) {
              alert("Please select exactly one merged Nare cell to unmerge.");
              return;
          }

          const mergedCell = selectedCells[0];
          const currentColspan = mergedCell.colSpan;

          if (currentColspan <= 1) {
              alert("The selected Nare cell is not merged.");
              return;
          }

          const day = mergedCell.dataset.day;
          const startNare = parseInt(mergedCell.dataset.nare);
          const originalContent = mergedCell.querySelector('.nare-content').innerHTML;

          // Reset the merged cell
          mergedCell.colSpan = 1;
          // For simplicity, put all content into the first unmerged cell
          // You might want more sophisticated content distribution here if needed
          mergedCell.querySelector('.nare-content').innerHTML = originalContent; 

          // Make subsequent cells visible and clear their content
          for (let i = 1; i < currentColspan; i++) {
              const nextNare = startNare + i;
              const nextCell = calendarBody.querySelector(`.nare-cell[data-day='${day}'][data-nare='${nextNare}']`);
              if (nextCell) {
                  nextCell.style.display = ''; // Make it visible
                  nextCell.colSpan = 1; // Ensure colspan is 1
                  nextCell.querySelector('.nare-content').innerHTML = ''; // Clear any residual content
              }
          }
          
          selectedCells.forEach(c => c.classList.remove("selected"));
          selectedCells = [];
          saveData(); // Save the unmerged state
          highlightWorkingHours(); // Re-highlight after unmerge
      });


      printBtn.addEventListener("click", () => window.print());

      todayBtn.addEventListener("click", () => {
        const today = getSiderealDate();
        
        yearSelect.value = today.year;
        seasonSelect.value = today.season;
        monthSelect.value = today.month;
        
        // Re-create calendar for the new date, which will also load its data and highlight working hours
        createCalendar(); 
        
        // Clear previous highlight
        if(currentHighlight) {
            currentHighlight.row.classList.remove('today-highlight');
            currentHighlight.nareCell.classList.remove('today-highlight-nare');
        }
        
        // Highlight the new 'today'
        const todayRow = calendarBody.querySelector(`tr[data-day-row='${today.day}']`);
        const todayNareCell = todayRow ? todayRow.querySelector(`.nare-cell[data-day='${today.day}'][data-nare='${today.nare}']`) : null;

        if (todayRow && todayNareCell) {
            todayRow.classList.add('today-highlight');
            todayNareCell.classList.add('today-highlight-nare');
            todayNareCell.scrollIntoView({ behavior: 'smooth', block: 'center' });
            currentHighlight = { row: todayRow, nareCell: todayNareCell };
        }
      });

      // --- Initialization ---
      function populateSelects() {
          for (let y = 0; y <= 100; y++) {
            const opt = document.createElement("option");
            opt.value = y; opt.textContent = y;
            yearSelect.appendChild(opt);
          }
          ["Α (Alpha)", "Β (Beta)", "Γ (Gamma)", "Δ (Delta)"].forEach((s, i) => {
            const opt = document.createElement("option");
            opt.value = i; opt.textContent = s;
            seasonSelect.appendChild(opt);
          });
          ["I", "II", "III", "IV", "V"].forEach((m, i) => {
            const opt = document.createElement("option");
            opt.value = i; opt.textContent = m;
            monthSelect.appendChild(opt);
          });
          
          const today = getSiderealDate();
          yearSelect.value = today.year;
          seasonSelect.value = today.season;
          monthSelect.value = today.month;

          yearSelect.addEventListener('change', handleDropdownChange);
          seasonSelect.addEventListener('change', handleDropdownChange);
          monthSelect.addEventListener('change', handleDropdownChange);
      }

      populateSelects();
      createCalendar();
      
      // *** PWA Service Worker Registration ***
      if ('serviceWorker' in navigator) {
        navigator.serviceWorker.register('sw.js').then(() => {
          console.log('Service Worker Registered for Calendar');
        }).catch(error => {
          console.error('Service Worker Registration Failed:', error);
        });
      }
      // *** End PWA Service Worker Registration ***

    });
  </script>
</body>
</html>
