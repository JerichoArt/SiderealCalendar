<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Sidereal Calendar</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <link rel="manifest" href="manifest.json"> <script src="https://cdn.tailwindcss.com"></script>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;700&display=swap" rel="stylesheet">
  <style>
    html, body {
      background-color: #f7fafc;
      color: #1a202c;
      margin: 0;
      padding: 0;
      font-family: 'Inter', sans-serif;
    }
    table {
      width: 100%;
      table-layout: fixed;
      border-collapse: collapse;
      border: 1px solid #e2e8f0;
      background-color: white;
    }
    th, td {
      border: 1px solid #e2e8f0;
      padding: 0.05rem;
      text-align: left;
      vertical-align: top;
    }
    /* Sticky controls section */
    .controls {
        position: sticky; /* Make controls sticky */
        top: 0; /* Stick to the top of the viewport */
        z-index: 10; /* Ensure it's above other content when sticky */
        background-color: white; /* Ensure it covers content when sticky */
        padding: 1rem;
        border-radius: 0.5rem;
        box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -1px rgba(0, 0, 0, 0.06);
    }
    /* Table header (thead th) will now scroll normally with the table */
    thead th {
      background-color: #edf2f7; /* Background color for the header cells */
      text-align: center;
      font-weight: 500;
      color: #4a5568;
      /* Removed: position: sticky, top, z-index, as the whole thead will scroll */
    }
    .day-number {
      font-size: 1.5rem;
      font-weight: bold;
      text-align: center;
      width: 70px;
      background-color: #f7fafc;
    }
    .whole-day-cell {
        min-height: 50px;
    }
    .nare-cell {
      min-height: 90px;
      overflow-wrap: break-word;
      position: relative;
    }
    .nare-content, .whole-day-content {
      min-height: 50px;
      width: 100%;
      outline: none;
      padding: 2px;
    }
    .nare-content:focus, .whole-day-content:focus {
        box-shadow: 0 0 0 2px rgba(66, 153, 225, 0.5);
        border-radius: 4px;
    }
	.nare-working-hours {
        background-color: #d1f7d1; /* A light green for working hours (screen display) */
    }

    .selected {
      background-color: #fefcbf; /* Softer yellow */
      border-color: #fbd38d;
    }
    .today-highlight {
        background-color: #e6f2ea; /* Light Grey */
    }
    .today-highlight-nare {
        background-color: #9ae6b4; /* Darker green */
    }
    
	    /* New styles for the control box */
    #nare-display-output {
      font-size: 0.9rem;
      color: #1a202c;
      background-color: #e2e8f0;
      border: 1px solid #cbd5e0;
      min-height: 38px; /* To match input/button height */
      display: flex;
      align-items: center;
      justify-content: center;
      text-align: center;
    }

	button {
        transition: background-color 0.2s ease-in-out, transform 0.1s ease-in-out;
    }
    button:active {
        transform: scale(0.98);
    }
    @media print {
      body {
        background: white;
        color: black;
      }
      /* Hide controls and specific buttons when printing */
      .controls, #merge-btn, #unmerge-btn, #print-btn, #today-btn, #year-select, #month-select, #season-select, label {
        display: none !important;
      }
      /* Ensure table borders are visible */
      table, th, td {
          border: 1px solid #ccc;
      }
      /* Print style for working hours: light grey fill */
      .nare-working-hours {
        background-color: #f0f0f0 !important; /* Very light grey for print */
        -webkit-print-color-adjust: exact; /* For WebKit browsers to print background colors */
        print-color-adjust: exact; /* Standard property for printing background colors */
      }
    }
  </style>
</head>
<body class="p-4 md:p-6">
  <div class="max-w-7xl mx-auto">
      <h1 class="text-3xl font-bold mb-4 text-center text-gray-800">Sidereal Calendar</h1>

      <div class="controls flex flex-wrap items-center gap-4 mb-4">
        <label class="flex items-center gap-2">Year: <select id="year-select" class="border border-gray-300 rounded px-2 py-1"></select></label>
        <label class="flex items-center gap-2">Season: <select id="season-select" class="border border-gray-300 rounded px-2 py-1"></select></label>
        <label class="flex items-center gap-2">Month: <select id="month-select" class="border border-gray-300 rounded px-2 py-1"></select></label>
        <div class="flex gap-2 ml-auto">
                  <div class="flex flex-col md:flex-row items-center gap-2 bg-gray-100 p-3 rounded-md shadow-inner ml-auto">
          <label for="datetime-input" class="text-gray-700 font-medium whitespace-nowrap">Go to:</label>
          <input type="text" id="datetime-input" placeholder="DD/MM/YYYY HH:MM" class="border border-gray-300 rounded px-2 py-1 text-gray-800 w-fit focus:ring-blue-500 focus:border-blue-500" style="width: fit-content;">
          <button id="go-to-btn" class="bg-green-500 hover:bg-green-600 text-white font-semibold px-3 py-1 rounded-md shadow-sm whitespace-nowrap">Go</button>
          <div id="nare-display-output" class="text-gray-800 font-medium bg-gray-200 px-3 py-1 rounded-md min-w-[150px] text-center">
            Click an Hour box
          </div>
        </div>
		<button id="merge-btn" class="bg-yellow-400 hover:bg-yellow-500 text-yellow-800 font-semibold px-4 py-2 rounded-md shadow-sm">Merge</button>
          <button id="unmerge-btn" class="bg-indigo-400 hover:bg-indigo-500 text-white font-semibold px-4 py-2 rounded-md shadow-sm">Unmerge</button>
          <button id="print-btn" class="bg-blue-500 hover:bg-blue-600 text-white font-semibold px-4 py-2 rounded-md shadow-sm">Print</button>
		  <button id="today-btn" class="bg-cyan-500 hover:bg-cyan-600 text-white font-semibold px-4 py-2 rounded-md shadow-sm">Today</button>
        </div>
      </div>

      <div class="overflow-x-auto shadow-lg rounded-lg">
        <table id="calendar-table">
          <thead>
            <tr id="header-row-main">
              <th rowspan="2">Day</th>
              <th rowspan="2">Whole Day</th>
              <th colspan="10">Hours</th>
            </tr>
             <tr id="header-row-sub">
                <th>1</th><th>2</th><th>3</th><th>4</th><th>5</th>
                <th>6</th><th>7</th><th>8</th><th>9</th><th>10</th>
            </tr>
          </thead>
          <tbody id="calendar-body"></tbody>
        </table>
      </div>
  </div>

  <script>
    document.addEventListener("DOMContentLoaded", function () {
      // --- DOM Elements ---
      const calendarBody = document.getElementById("calendar-body");
      const mergeBtn = document.getElementById("merge-btn");
      const unmergeBtn = document.getElementById("unmerge-btn");
      const printBtn = document.getElementById("print-btn");
      const todayBtn = document.getElementById("today-btn");
      const yearSelect = document.getElementById("year-select");
      const seasonSelect = document.getElementById("season-select");
      const monthSelect = document.getElementById("month-select");

      // --- Calendar & Clock Constants ---
      const DAYS_IN_MONTH = 50;
      const NARES_PER_DAY = 10;
      const SIDEREAL_YEAR_SECS = (365 * 86400) + (5 * 3600) + (48 * 60) + 45;
      // Epoch set to J2000 epoch as 0 hour for both calendars (UTC)
      const EPOCH = new Date('2000-01-01T00:00:00.000Z'); 
      const DAYS_IN_YEAR = 1000;
      const MONTHS_PER_SEASON = 5;
      const PINGS_PER_SEC = 10;
      const SECS_PER_DIN = 10;
      const DINS_PER_NARE = 50;
      const PING_LENGTH = SIDEREAL_YEAR_SECS / (DAYS_IN_YEAR * NARES_PER_DAY * DINS_PER_NARE * SECS_PER_DIN * PINGS_PER_SEC);
      const SECONDS_PER_NARE_REAL = SIDEREAL_YEAR_SECS / (DAYS_IN_YEAR * NARES_PER_DAY);

// --- NEW CODE BLOCK STARTS HERE ---
      // --- New DOM Elements for Control Box ---
      const datetimeInput = document.getElementById("datetime-input");
      const goToBtn = document.getElementById("go-to-btn");
      const nareDisplayOutput = document.getElementById("nare-display-output");

      // --- New function: Convert Gregorian to Sidereal ---
      // This function takes a Gregorian Date object and returns its corresponding Sidereal date components.
      function getSiderealDateFromGregorian(gregorianDate) {
        // Ensure the date is not before the EPOCH
        if (gregorianDate.getTime() < EPOCH.getTime()) {
          console.error("Date is before J2000 epoch. Cannot convert.");
          return null;
        }

        const elapsed = (gregorianDate.getTime() - EPOCH.getTime()) / 1000; // Elapsed seconds from EPOCH

        const totalPings = elapsed / PING_LENGTH;
        const totalNares = totalPings / (PINGS_PER_SEC * SECS_PER_DIN * DINS_PER_NARE);
        const totalDays = Math.floor(totalNares / NARES_PER_DAY);

        const siderealYear = Math.floor(elapsed / SIDEREAL_YEAR_SECS);
        const dayOfYear = totalDays % DAYS_IN_YEAR;

        const daysPerSeason = DAYS_IN_MONTH * MONTHS_PER_SEASON;
        const seasonIndex = Math.floor(dayOfYear / daysPerSeason);
        const dayInSeason = dayOfYear % daysPerSeason;

        const monthIndex = Math.floor(dayInSeason / DAYS_IN_MONTH);
        const dayInMonth = (dayInSeason % DAYS_IN_MONTH) + 1; // 1-indexed day
        const nareOfDay = Math.floor(totalNares % NARES_PER_DAY) + 1; // 1-indexed Nare

        // Calculate Dins and Pings within the current Nare for more precise time
        const naresElapsedInDay = totalNares % NARES_PER_DAY;
        const dinsInNare = Math.floor((naresElapsedInDay - Math.floor(naresElapsedInDay)) * DINS_PER_NARE);
        const pingsInDin = Math.floor((((naresElapsedInDay - Math.floor(naresElapsedInDay)) * DINS_PER_NARE) - dinsInNare) * SECS_PER_DIN * PINGS_PER_SEC);

        return {
          year: siderealYear,
          season: seasonIndex,
          month: monthIndex,
          day: dayInMonth,
          nare: nareOfDay,
          din: dinsInNare,
          ping: pingsInDin
        };
      }
	
      // --- Event Listener for Nare Cell Clicks (to display in control box) ---
      // Modify the createCalendar function to attach this listener
      // Find the existing `nareCell.addEventListener('click', ...)` or similar block
      // and replace or augment it with the following:
      function attachNareClickListeners() {
        document.querySelectorAll('.nare-content').forEach(nareContent => {
          nareContent.removeEventListener('click', handleNareContentClick); // Remove old listener if exists
          nareContent.addEventListener('click', handleNareContentClick);
        });
      }

      function handleNareContentClick(event) {
          isLocked = true; // ðŸ”’ Lock it
		          const nareContent = event.target;
          const nareCell = nareContent.closest('.nare-cell');
          const day = parseInt(nareCell.dataset.day);
          const nare = parseInt(nareCell.dataset.nare);

        const siderealYear = parseInt(yearSelect.value);
        const seasonIndex = parseInt(seasonSelect.value);
        const monthIndex = parseInt(monthSelect.value);

        // Get the Gregorian date for the clicked Nare
        const gregorianDate = getGregorianDateFromSidereal(siderealYear, seasonIndex, monthIndex, day, nare);

        // Format the Gregorian date and time
        const formattedDate = gregorianDate.toLocaleDateString('en-GB', {
          year: 'numeric',
          month: '2-digit',
          day: '2-digit'
        });
        const formattedTime = gregorianDate.toLocaleTimeString('en-GB', {
          hour: '2-digit',
          minute: '2-digit',
          hour12: false // Use 24-hour format
        });

        nareDisplayOutput.textContent = `${formattedDate} ${formattedTime}`;
      }
		document.addEventListener('click', (e) => {
		if (
		!e.target.closest('.nare-cell') &&
		!e.target.closest('#calendar-body') &&
		!e.target.closest('#nare-display-output')
		) {
		isLocked = false;
		nareDisplayOutput.textContent = "Click an Hour box";
	}
	});

      // --- Event Listener for Control Box Input (to navigate to Nare box) ---
      goToBtn.addEventListener('click', function() {
        const inputString = datetimeInput.value.trim();
        if (!inputString) {
          nareDisplayOutput.textContent = "Please enter a date and time.";
          return;
        }

        const [datePart, timePart] = inputString.split(' ');
		//marker from this point
		
        if (!datePart || !timePart) {
          nareDisplayOutput.textContent = "Invalid format. Use YYYY-MM-DD HH:MM";
          return;
        }
		// marker to this point 
        const [day, month, year] = datePart.split('/').map(Number);
        const [hours, minutes] = timePart.split(':').map(Number);
		const seconds = 0; // Set seconds to 0
		
        // Note: Month in Date constructor is 0-indexed
        const gregorianInputDate = new Date(year, month - 1, day, hours, minutes);

// Add a small offset (1 minute) to ensure we are in the middle of the Nare
            gregorianInputDate.setMinutes(gregorianInputDate.getMinutes() + 1);
// Convert to Sidereal Date
            const siderealDate = getSiderealDateFromGregorian(gregorianInputDate);

        if (isNaN(gregorianInputDate.getTime())) {
          nareDisplayOutput.textContent = "Invalid date/time entered.";
          return;
        }

        if (gregorianInputDate.getTime() < EPOCH.getTime()) {
          nareDisplayOutput.textContent = "Date must be after J2000 epoch (2000-01-01 00:00:00 UTC).";
          return;
        }

        const siderealTarget = getSiderealDateFromGregorian(gregorianInputDate);

        if (siderealTarget) {
          // Update dropdowns if necessary
          yearSelect.value = siderealTarget.year;
          seasonSelect.value = siderealTarget.season;
          monthSelect.value = siderealTarget.month;

          // Re-create calendar to show the correct month/season/year
          createCalendar();

          // Find and "click" the target Nare box
          // Use setTimeout to ensure the calendar has re-rendered
          setTimeout(() => {
            const targetCell = document.querySelector(
              `.nare-cell[data-day="${siderealTarget.day}"][data-nare="${siderealTarget.nare}"]`
            );
            if (targetCell) {
              targetCell.scrollIntoView({ behavior: 'smooth', block: 'center' });
				targetCell.querySelector('.nare-content').focus();
              nareDisplayOutput.textContent = `Mapped to Year ${siderealTarget.year}, Season ${siderealTarget.season+1}, Month ${siderealTarget.month+1}, Day ${siderealTarget.day}, Hour ${siderealTarget.nare}`;
            } else {
              nareDisplayOutput.textContent = "Could not find target Hour box.";
            }
          }, 100); // Small delay to allow DOM update
        } else {
          nareDisplayOutput.textContent = "Error converting date.";
        }
      });
      // --- NEW CODE BLOCK ENDS HERE ---

      let selectedCells = [];
      let currentHighlight = null;

      // --- Sidereal Clock Logic (from real-world to sidereal) ---
      function getSiderealDate() {
        const nowDate = new Date(); // Current real-world date/time
        const elapsed = (Date.now() - EPOCH.getTime()) / 1000; // Elapsed seconds from EPOCH
        const totalPings = elapsed / PING_LENGTH;
        
        const totalNares = totalPings / (PINGS_PER_SEC * SECS_PER_DIN * DINS_PER_NARE);
        const totalDays = Math.floor(totalNares / NARES_PER_DAY);
        
        const siderealYear = Math.floor(elapsed / SIDEREAL_YEAR_SECS);
        const dayOfYear = totalDays % DAYS_IN_YEAR;
        
        const daysPerSeason = DAYS_IN_MONTH * MONTHS_PER_SEASON;
        const seasonIndex = Math.floor(dayOfYear / daysPerSeason);
        const dayInSeason = dayOfYear % daysPerSeason;
        
        const monthIndex = Math.floor(dayInSeason / DAYS_IN_MONTH);
        const dayInMonth = (dayInSeason % DAYS_IN_MONTH) + 1;
        
        const nareOfDay = Math.floor(totalNares % NARES_PER_DAY) + 1; // 1-indexed Nare

        return { year: siderealYear, season: seasonIndex, month: monthIndex, day: dayInMonth, nare: nareOfDay };
      }

      // --- New function: Convert Sidereal to Gregorian (from sidereal to real-world) ---
      function getGregorianDateFromSidereal(siderealYear, seasonIndex, monthIndex, dayInMonth, nareNumber) {
          const daysPerSeason = DAYS_IN_MONTH * MONTHS_PER_SEASON;
          // Calculate total sidereal days from Epoch to the beginning of the target sidereal day
          const totalSiderealDaysFromEpoch = 
              (siderealYear * DAYS_IN_YEAR) + 
              (seasonIndex * daysPerSeason) + 
              (monthIndex * DAYS_IN_MONTH) + 
              (dayInMonth - 1); // dayInMonth is 1-indexed, convert to 0-indexed for calculation

          // Calculate total Nares from Epoch to the beginning of the target Nare
          const totalNaresFromEpoch = (totalSiderealDaysFromEpoch * NARES_PER_DAY) + (nareNumber - 1); // nareNumber is 1-indexed

          // Calculate total real-world seconds from Epoch to the beginning of the target Nare
          const elapsedRealSeconds = totalNaresFromEpoch * SECONDS_PER_NARE_REAL;

          // Add these elapsed seconds (converted to milliseconds) to the EPOCH date
          return new Date(EPOCH.getTime() + (elapsedRealSeconds * 1000));
      }
	// Generic debounce function to limit how often a function is called
      const debounce = (func, delay) => {
          let timeoutId;
          return (...args) => {
              clearTimeout(timeoutId);
              timeoutId = setTimeout(() => {
                  func.apply(this, args);
              }, delay);
          };
      };
	  const debouncedSaveData = debounce(saveData, 500);
	  
      // --- Data Persistence (Local Storage) ---
      function getStorageKey() {
        return `sidereal-calendar-${yearSelect.value}-${seasonSelect.value}-${monthSelect.value}`;
      }

      function saveData() {
        const key = getStorageKey();
        const data = {
          wholeDay: {},
          nares: {}
        };
        const rows = calendarBody.querySelectorAll('tr');
        rows.forEach((row, dayIndex) => {
          const day = dayIndex + 1;
          const wholeDayContent = row.querySelector('.whole-day-content');
          if (wholeDayContent && wholeDayContent.innerHTML) {
            data.wholeDay[day] = wholeDayContent.innerHTML;
          }

          const nareCells = row.querySelectorAll('.nare-cell');
          nareCells.forEach(cell => {
            // Only save if the cell is visible (not hidden due to merge) or if it's the start of a merged block
            if (cell.style.display !== 'none' || cell.colSpan > 1) { 
              const nare = cell.dataset.nare;
              const content = cell.querySelector('.nare-content').innerHTML;
              const colspan = cell.colSpan;
              if (content || colspan > 1) { // Save if content exists or if it's a merged cell
                if (!data.nares[day]) data.nares[day] = {};
                data.nares[day][nare] = { content, colspan };
              }
            }
          });
        });
        localStorage.setItem(key, JSON.stringify(data));
      }

      function loadData() {
        const key = getStorageKey();
        const data = JSON.parse(localStorage.getItem(key));
        
        // Reset all cells to default display/colspan before loading
        const allNareCells = calendarBody.querySelectorAll('.nare-cell');
        allNareCells.forEach(cell => {
            cell.style.display = '';
            cell.colSpan = 1;
            cell.querySelector('.nare-content').innerHTML = ''; // Clear content to ensure fresh load
        });

        if (!data) return;

        // Load whole day content
        for (const day in data.wholeDay) {
          const cell = calendarBody.querySelector(`tr:nth-child(${day}) .whole-day-content`);
          if (cell) cell.innerHTML = data.wholeDay[day];
        }

        // Load nare content and handle merges
        for (const day in data.nares) {
          for (const nare in data.nares[day]) {
            const cellData = data.nares[day][nare];
            const cell = calendarBody.querySelector(`.nare-cell[data-day='${day}'][data-nare='${nare}']`);
            if (!cell) continue;

            cell.querySelector('.nare-content').innerHTML = cellData.content || '';
            if (cellData.colspan > 1) {
              cell.colSpan = cellData.colspan;
              // Hide the cells that are spanned over
              for (let i = 1; i < cellData.colspan; i++) {
                const nextNare = parseInt(nare) + i;
                const nextCell = calendarBody.querySelector(`.nare-cell[data-day='${day}'][data-nare='${nextNare}']`);
                if (nextCell) nextCell.style.display = 'none';
              }
            }
          }
        }
      }

      // --- UI & Calendar Generation ---
      
      function createCalendar() {
        calendarBody.innerHTML = ''; // Clear existing calendar
        for (let day = 1; day <= DAYS_IN_MONTH; day++) {
          const tr = document.createElement("tr");
          tr.dataset.dayRow = day;

          const dayTd = document.createElement("td");
          dayTd.className = "day-number";
          dayTd.textContent = day;
          tr.appendChild(dayTd);

          const wholeDayTd = document.createElement("td");
          wholeDayTd.className = "whole-day-cell";
          const wholeContent = document.createElement("div");
          wholeContent.contentEditable = true;
          wholeContent.className = "whole-day-content";
          wholeContent.addEventListener('input', debouncedSaveData);
          wholeDayTd.appendChild(wholeContent);
          tr.appendChild(wholeDayTd);

          for (let i = 1; i <= NARES_PER_DAY; i++) {
            const td = document.createElement("td");
            td.className = "nare-cell";
            td.dataset.day = day;
            td.dataset.nare = i;
            const nareContent = document.createElement("div");
            nareContent.className = "nare-content";
            nareContent.contentEditable = true;
            nareContent.addEventListener('input', debouncedSaveData);
            nareContent.addEventListener('click', handleNareContentClick);
			td.appendChild(nareContent);
            td.addEventListener("click", (e) => handleCellClick(e, td));
            tr.appendChild(td);
          }
          
          calendarBody.appendChild(tr);
        }
        loadData(); // Load data after creating the structure
        highlightWorkingHours(); // Call the dynamic highlighting function after loading data
      }

      // --- Function to dynamically highlight working hours (9 AM - 5 PM) ---
      function highlightWorkingHours() {
          const rows = calendarBody.querySelectorAll('tr');
          const currentSiderealYear = parseInt(yearSelect.value);
          const currentSeasonIndex = parseInt(seasonSelect.value);
          const currentMonthIndex = parseInt(monthSelect.value);

          rows.forEach(row => {
              const siderealDayInMonth = parseInt(row.dataset.dayRow);
              const nareCells = row.querySelectorAll('.nare-cell');

              nareCells.forEach(cell => {
                  cell.classList.remove('nare-working-hours'); // Reset first

                  const nareNumber = parseInt(cell.dataset.nare); // 1-indexed Nare

                  // Calculate Gregorian start Date object for this Nare
                  const gregorianNareStart = getGregorianDateFromSidereal(
                      currentSiderealYear,
                      currentSeasonIndex,
                      currentMonthIndex,
                      siderealDayInMonth,
                      nareNumber
                  );
                  
                  // Calculate Gregorian end time of this Nare
                  const gregorianNareEnd = new Date(gregorianNareStart.getTime() + (SECONDS_PER_NARE_REAL * 1000));

                  // Get the local date components from the Nare's start time
                  const nareLocalYear = gregorianNareStart.getFullYear();
                  const nareLocalMonth = gregorianNareStart.getMonth();
                  const nareLocalDay = gregorianNareStart.getDate();

                  // Create Date objects for 9 AM and 5 PM in the *local timezone* for the Nare's day
                  // These will automatically convert to UTC timestamps based on local timezone offset
                  const workingHoursStart = new Date(nareLocalYear, nareLocalMonth, nareLocalDay, 9, 0, 0);
                  const workingHoursEnd = new Date(nareLocalYear, nareLocalMonth, nareLocalDay, 17, 0, 0);

                  // Check for overlap between Nare time window and working hours window
                  // A Nare is highlighted if any part of it falls within the 9 AM - 5 PM window
                  const isWorkingHours = (gregorianNareEnd.getTime() > workingHoursStart.getTime()) &&
                                         (gregorianNareStart.getTime() < workingHoursEnd.getTime());
                  
                  if (isWorkingHours) {
                      cell.classList.add('nare-working-hours');
					  
					  
                  }
              });
          });
      }

      // --- Event Handlers ---
      function handleCellClick(event, cell) {
        if (!event.ctrlKey && !event.shiftKey) { // Allow Ctrl/Shift for multiple selection
            selectedCells.forEach(c => c.classList.remove("selected"));
            selectedCells = [];
        }
        if (selectedCells.includes(cell)) {
            cell.classList.remove("selected");
            selectedCells = selectedCells.filter(c => c !== cell);
        } else {
            cell.classList.add("selected");
            selectedCells.push(cell);
        }
      }
      
      function handleDropdownChange() {
        createCalendar(); // This will also trigger loadData for the new selection and call highlightWorkingHours
      }

      mergeBtn.addEventListener("click", () => {
        if (selectedCells.length < 2) {
            alert("Select at least two Hours to merge.");
            return;
        }
        selectedCells.sort((a, b) => parseInt(a.dataset.nare) - parseInt(b.dataset.nare));
        
        const firstDay = selectedCells[0].dataset.day;
        if (!selectedCells.every(cell => cell.dataset.day === firstDay)) {
            alert("You can only merge Hours from the same day.");
            return;
        }

        // Check for continuity and if any selected cell is already part of a merge
        for (let i = 0; i < selectedCells.length - 1; i++) {
            const currentNare = parseInt(selectedCells[i].dataset.nare);
            const nextNare = parseInt(selectedCells[i+1].dataset.nare);
            if (nextNare !== currentNare + 1) {
                alert("Selected Nares must be consecutive to merge.");
                selectedCells.forEach(c => c.classList.remove("selected"));
                selectedCells = [];
                return;
            }
            if (selectedCells[i].colSpan > 1 || selectedCells[i].style.display === 'none') {
                 alert("Cannot merge cells that are already part of an existing merge.");
                 selectedCells.forEach(c => c.classList.remove("selected"));
                 selectedCells = [];
                 return;
            }
        }
        // Also check the last cell if it's already merged
        if (selectedCells[selectedCells.length - 1].colSpan > 1 || selectedCells[selectedCells.length - 1].style.display === 'none') {
             alert("Cannot merge cells that are already part of an existing merge.");
             selectedCells.forEach(c => c.classList.remove("selected"));
             selectedCells = [];
             return;
        }


        const firstCell = selectedCells[0];
        let mergedContent = selectedCells.map(cell => cell.querySelector('.nare-content').innerHTML).filter(Boolean);
        firstCell.querySelector('.nare-content').innerHTML = mergedContent.join("<br>");
        firstCell.colSpan = selectedCells.length;
        firstCell.style.display = ''; // Ensure first cell is visible

        for (let i = 1; i < selectedCells.length; i++) {
            selectedCells[i].style.display = 'none';
        }

        selectedCells.forEach(c => c.classList.remove("selected"));
        selectedCells = [];
        saveData(); // Save the new merged state
      });

      unmergeBtn.addEventListener("click", () => {
          if (selectedCells.length !== 1) {
              alert("Please select exactly one merged Hour cell to unmerge.");
              return;
          }

          const mergedCell = selectedCells[0];
          const currentColspan = mergedCell.colSpan;

          if (currentColspan <= 1) {
              alert("The selected Nare cell is not merged.");
              return;
          }

          const day = mergedCell.dataset.day;
          const startNare = parseInt(mergedCell.dataset.nare);
          const originalContent = mergedCell.querySelector('.nare-content').innerHTML;

          // Reset the merged cell
          mergedCell.colSpan = 1;
          // For simplicity, put all content into the first unmerged cell
          // You might want more sophisticated content distribution here if needed
          mergedCell.querySelector('.nare-content').innerHTML = originalContent; 

          // Make subsequent cells visible and clear their content
          for (let i = 1; i < currentColspan; i++) {
              const nextNare = startNare + i;
              const nextCell = calendarBody.querySelector(`.nare-cell[data-day='${day}'][data-nare='${nextNare}']`);
              if (nextCell) {
                  nextCell.style.display = ''; // Make it visible
                  nextCell.colSpan = 1; // Ensure colspan is 1
                  nextCell.querySelector('.nare-content').innerHTML = ''; // Clear any residual content
              }
          }
          
          selectedCells.forEach(c => c.classList.remove("selected"));
          selectedCells = [];
          saveData(); // Save the unmerged state
          highlightWorkingHours(); // Re-highlight after unmerge
      });



      calendarBody.addEventListener('mouseover', (e) => {
          if (isLocked) return; // Don't overwrite if locked
		  const targetCell = e.target.closest('.nare-cell');
          if (!targetCell) {
              return;
          }

          // Get sidereal date from the hovered cell and dropdowns
          const siderealYear = parseInt(yearSelect.value);
          const seasonIndex = parseInt(seasonSelect.value);
          const monthIndex = parseInt(monthSelect.value);
          const siderealDayInMonth = parseInt(targetCell.dataset.day);
          const nareNumber = parseInt(targetCell.dataset.nare);

          // Calculate real-world start and end times
          const gregorianNareStart = getGregorianDateFromSidereal(
              siderealYear,
              seasonIndex,
              monthIndex,
              siderealDayInMonth,
              nareNumber
          );
          const gregorianNareEnd = new Date(gregorianNareStart.getTime() + (SECONDS_PER_NARE_REAL * 1000));
          
          // Format the times for display
          const startTime = gregorianNareStart.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });
          const endTime = gregorianNareEnd.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });
          
		nareDisplayOutput.textContent = `${gregorianNareStart.toLocaleDateString()} ${gregorianNareStart.toLocaleTimeString()} to ${gregorianNareEnd.toLocaleTimeString()}`;


          // Position the tooltip near the mouse cursor
          const rect = targetCell.getBoundingClientRect();
          const scrollTop = window.pageYOffset || document.documentElement.scrollTop;
          const scrollLeft = window.pageXOffset || document.documentElement.scrollLeft;

      });
		// No action on mouseout anymore
		calendarBody.addEventListener('mouseout', (e) => {
		// Do nothing: keep lock as is
	});

		// *** Touch Event Listeners for Multi-Cell Selection (for mobile) ***
      let touchSelectionActive = false;

      calendarBody.addEventListener('touchstart', (e) => {
          const targetCell = e.target.closest('.nare-cell');
          if (!targetCell) return;
          
          touchSelectionActive = true;
          // Clear and select the first cell touched
          selectedCells.forEach(cell => cell.classList.remove('selected'));
          selectedCells = [targetCell];
          targetCell.classList.add('selected');
      });

      calendarBody.addEventListener('touchmove', (e) => {
          if (!touchSelectionActive) return;

          const touch = e.touches[0];
          const targetCell = document.elementFromPoint(touch.clientX, touch.clientY);
          const cell = targetCell.closest('.nare-cell');

          if (cell && !selectedCells.includes(cell)) {
              cell.classList.add('selected');
              selectedCells.push(cell);
          }
      });

      calendarBody.addEventListener('touchend', () => {
          touchSelectionActive = false;
      });
      // *** End Touch Event Listeners ***

      printBtn.addEventListener("click", () => window.print());

      todayBtn.addEventListener("click", () => {
        const today = getSiderealDate();
        
        yearSelect.value = today.year;
        seasonSelect.value = today.season;
        monthSelect.value = today.month;
        
        // Re-create calendar for the new date, which will also load its data and highlight working hours
        createCalendar(); 
        
        // Clear previous highlight
        if(currentHighlight) {
            currentHighlight.row.classList.remove('today-highlight');
            currentHighlight.nareCell.classList.remove('today-highlight-nare');
        }
        
        // Highlight the new 'today'
        const todayRow = calendarBody.querySelector(`tr[data-day-row='${today.day}']`);
        const todayNareCell = todayRow ? todayRow.querySelector(`.nare-cell[data-day='${today.day}'][data-nare='${today.nare}']`) : null;

        if (todayRow && todayNareCell) {
            todayRow.classList.add('today-highlight');
            todayNareCell.classList.add('today-highlight-nare');
            todayNareCell.scrollIntoView({ behavior: 'smooth', block: 'center' });
            currentHighlight = { row: todayRow, nareCell: todayNareCell };
        }
      });

      // --- Initialization ---
      function populateSelects() {
          for (let y = 0; y <= 100; y++) {
            const opt = document.createElement("option");
            opt.value = y; opt.textContent = y;
            yearSelect.appendChild(opt);
          }
          ["Î‘ (Alpha)", "Î’ (Beta)", "Î“ (Gamma)", "Î” (Delta)"].forEach((s, i) => {
            const opt = document.createElement("option");
            opt.value = i; opt.textContent = s;
            seasonSelect.appendChild(opt);
          });
          ["I", "II", "III", "IV", "V"].forEach((m, i) => {
            const opt = document.createElement("option");
            opt.value = i; opt.textContent = m;
            monthSelect.appendChild(opt);
          });
          
          const today = getSiderealDate();
          yearSelect.value = today.year;
          seasonSelect.value = today.season;
          monthSelect.value = today.month;

          yearSelect.addEventListener('change', handleDropdownChange);
          seasonSelect.addEventListener('change', handleDropdownChange);
          monthSelect.addEventListener('change', handleDropdownChange);
      }

      populateSelects();
      createCalendar();
	  
	        
      // *** PWA Service Worker Registration ***
      if ('serviceWorker' in navigator) {
        navigator.serviceWorker.register('sw.js').then(() => {
          console.log('Service Worker Registered for Calendar');
        }).catch(error => {
          console.error('Service Worker Registration Failed:', error);
        });
      }
      // *** End PWA Service Worker Registration ***

    });
  </script>
</body>
</html>
